(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{220:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.meta=void 0;var s=d(t(2)),i=t(528),o=d(t(529)),a=d(t(531)),l=d(t(530)),r=d(t(831)),u=d(t(830)),c=d(t(618));function d(e){return e&&e.__esModule?e:{default:e}}var m=n.meta={title:"Menu",toc:["Пример","Свойства  <Menu />","Свойства  <MenuItem />"]},p=s.default.createElement(a.default,{code:r.default}),h=s.default.createElement(l.default,{code:u.default}),y=s.default.createElement(l.default,{code:c.default});n.default=function(e){var n=e.components,t=function(e,n){var t={};for(var s in e)n.indexOf(s)>=0||Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}(e,["components"]);return s.default.createElement(i.MDXTag,{name:"wrapper",Layout:(0,o.default)(m)(function(e){return e.children}),layoutProps:t,components:n},s.default.createElement(i.MDXTag,{name:"h3",components:n},"Пример"),p,s.default.createElement(i.MDXTag,{name:"h3",components:n},"Свойства ",s.default.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"h3"},"<Menu />")),h,s.default.createElement(i.MDXTag,{name:"h3",components:n},"Свойства ",s.default.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"h3"},"<MenuItem />")),y)}},618:function(e,n){e.exports="import React, {PureComponent} from 'react'\nimport PropTypes from 'prop-types'\nimport classnames from 'classnames'\nimport {ENTER} from '../constants/keys'\nimport {injectSheet} from '../theme'\nimport {isolateMixin} from '../utils/mixins'\nimport EventEmitter from 'events'\nimport uuid from '../utils/uuid'\nimport {MENU_ITEM_CONTEXT} from '../constants/context'\n\n@injectSheet(\n  theme => ({\n    root: {\n      extend: isolateMixin,\n      fontFamily: theme.fontFamily,\n      boxSizing: 'border-box',\n      display: 'flex',\n      alignItems: 'center',\n      flexWrap: 'wrap',\n      paddingLeft: theme.menu.padding,\n      paddingRight: theme.menu.padding,\n      outline: 0,\n      fontSize: theme.menu.fontSize,\n      lineHeight: theme.menu.lineHeight + 'px'\n    },\n    ...['medium', 'small'].reduce(\n      (result, size) => ({\n        ...result,\n        [size]: {\n          minHeight: theme.menu.sizes[size].height,\n          paddingTop:\n            (theme.menu.sizes[size].height - theme.menu.lineHeight) / 2,\n          paddingBottom:\n            (theme.menu.sizes[size].height - theme.menu.lineHeight) / 2\n        }\n      }),\n      {}\n    ),\n    isEnabled: {\n      color: theme.menu.colors.default.text,\n      backgroundColor: theme.menu.colors.default.background,\n      cursor: 'pointer',\n      '&:hover': {\n        color: theme.menu.colors.hover.text,\n        backgroundColor: theme.menu.colors.hover.background\n      },\n      '&:focus': {\n        color: theme.menu.colors.focus.text,\n        background: theme.menu.colors.focus.background\n      },\n      '&:active': {\n        color: theme.menu.colors.active.text,\n        background: theme.menu.colors.active.background\n      }\n    },\n    isSelected: {\n      color: theme.menu.colors.selected.text\n    },\n    isDisabled: {\n      color: theme.menu.colors.disabled.text,\n      background: theme.menu.colors.disabled.background,\n      cursor: 'not-allowed'\n    }\n  }),\n  {name: 'MenuItem'}\n)\nclass MenuItem extends PureComponent {\n  static propTypes = {\n    /**\n     * Дополнительный CSS-класс\n     */\n    className: PropTypes.string,\n    /**\n     * Inline-стили\n     */\n    style: PropTypes.object,\n    /**\n     * Значение опции, по-умолчанию считается, что это примитив\n     */\n    value: PropTypes.any.isRequired,\n    /**\n     * Контент опции\n     */\n    children: PropTypes.node.isRequired\n  }\n\n  static contextTypes = {\n    [MENU_ITEM_CONTEXT]: PropTypes.shape({\n      /**\n       * Проверка, выбрано ли значение (args: value)\n       */\n      isValueSelected: PropTypes.func,\n      /**\n       * Проверка, в фокусе ли значение (args: key)\n       */\n      isItemFocused: PropTypes.func,\n      /**\n       * Проверка, не активно ли меню\n       */\n      isMenuDisabled: PropTypes.func,\n      /**\n       * Получение размера меню\n       */\n      getMenuSize: PropTypes.func,\n      /**\n       * Шина событий\n       * onPropsChange - изменение значений props в Menu, влияющих на отображение опций\n       * onItemSelect - клик по MenuItem (args: value)\n       * onItemFocus - фокус на MenuItem (args: id)\n       * onItemMount - добавление и обновление MenuItem (args: id, componentInstanseRef)\n       * onItemUnmount - удаление MenuItem (args: id)\n       */\n      events: PropTypes.instanceOf(EventEmitter)\n    })\n  }\n\n  id = uuid()\n\n  get ctx() {\n    return this.context[MENU_ITEM_CONTEXT]\n  }\n\n  componentDidMount() {\n    this.ctx.events.on('onPropsChange', this.handlePropsChange)\n    this.ctx.events.emit('onItemMount', this.id, this)\n    if (this.ctx.isItemFocused(this.id)) this.item.focus()\n  }\n\n  componentDidUpdate() {\n    if (this.ctx.isItemFocused(this.id)) this.item.focus()\n  }\n\n  componentWillUnmount() {\n    this.ctx.events.removeListener('onPropsChange', this.handlePropsChange)\n    this.ctx.events.emit('onItemUnmount', this.id)\n  }\n\n  handlePropsChange = () => {\n    const {props, ctx} = this\n    if (\n      ctx.isValueSelected(props.value) !== this.isSelected ||\n      ctx.isItemFocused(this.id) !== this.isFocused ||\n      ctx.isMenuDisabled() !== this.disabled ||\n      ctx.getMenuSize() !== this.size\n    )\n      this.forceUpdate()\n  }\n\n  handleFocus = () => {\n    this.ctx.events.emit('onItemFocus', this.id)\n  }\n\n  handleSelect = () => {\n    this.ctx.events.emit('onItemSelect', this.props.value)\n  }\n\n  handlePressKey = event => {\n    if (event.keyCode === ENTER) {\n      event.stopPropagation()\n      this.item.focus()\n      this.handleSelect()\n    }\n  }\n\n  saveRef = ref => {\n    this.item = ref\n  }\n\n  render() {\n    const {\n      className,\n      style,\n      value,\n      classes,\n      children,\n      theme, // eslint-disable-line no-unused-vars\n      ...other\n    } = this.props\n    this.isSelected = this.ctx.isValueSelected(value)\n    this.isFocused = this.ctx.isItemFocused(this.id)\n    this.disabled = this.ctx.isMenuDisabled()\n    this.size = this.ctx.getMenuSize()\n\n    return (\n      <div\n        {...other}\n        ref={this.saveRef}\n        style={style}\n        className={classnames(\n          className,\n          classes.root,\n          this.size && classes[this.size],\n          this.disabled ? classes.isDisabled : classes.isEnabled,\n          this.isSelected && classes.isSelected\n        )}\n        tabIndex={this.disabled ? null : 0}\n        onFocus={this.disabled ? null : this.handleFocus}\n        onClick={this.disabled ? null : this.handleSelect}\n        onKeyDown={this.disabled ? null : this.handlePressKey}\n        data-menu-item-id={this.id}>\n        {children}\n      </div>\n    )\n  }\n}\n\nMenuItem.displayName = 'ruiMenuItem'\n\nexport default MenuItem\n"},830:function(e,n){e.exports="import React, {PureComponent} from 'react'\nimport {findDOMNode} from 'react-dom'\nimport PropTypes from 'prop-types'\nimport classnames from 'classnames'\nimport EventEmitter from 'events'\nimport {ESCAPE, UP, DOWN, TAB} from '../constants/keys'\nimport {injectSheet} from '../theme'\nimport {getBoundingClientRect} from '../utils/DOM'\nimport {isolateMixin, beautyScroll} from '../utils/mixins'\nimport {MENU_ITEM_CONTEXT} from '../constants/context'\n\nconst emptyArr = []\n\n@injectSheet(\n  theme => ({\n    menu: {\n      extend: isolateMixin,\n      fontFamily: theme.fontFamily,\n      boxSizing: 'border-box',\n      padding: 0,\n      overflowY: 'auto',\n      ...beautyScroll('&')\n    }\n  }),\n  {name: 'Menu'}\n)\nexport default class Menu extends PureComponent {\n  static propTypes = {\n    /**\n     * Дополнительный CSS-класс поля\n     */\n    className: PropTypes.string,\n    /**\n     * Inline-стили поля\n     */\n    style: PropTypes.object,\n    /**\n     * Множественный выбор\n     */\n    multiple: PropTypes.bool,\n    /**\n     * Опции не активны\n     */\n    disabled: PropTypes.bool,\n    /**\n     * Автофокус первого/выбранного элемента\n     */\n    autoFocus: PropTypes.bool,\n    /**\n     * Максимальная высота компонента\n     */\n    maxHeight: PropTypes.number,\n    /**\n     * Выбранное значение, по-умолчанию считается, что это примитив. В случае множественного выбора - массив выбранных значений.\n     */\n    value: PropTypes.any,\n    /**\n     * Проверка равенства значений, задается, если\n     * значением является объект. Ожидается, что возвращает `Boolean`\n     */\n    valuesEquality: PropTypes.func,\n    /**\n     * Опции поля\n     */\n    children: PropTypes.oneOfType([\n      PropTypes.element,\n      PropTypes.arrayOf(PropTypes.element)\n    ]),\n    /**\n     * Коллбек, вызывающийся при изменении состояния\n     */\n    onChange: PropTypes.func,\n    /**\n     * Коллбек, вызывающийся при клике на `Escape`\n     */\n    onEscKeyDown: PropTypes.func,\n    /**\n     * Размер опций\n     */\n    size: PropTypes.oneOf(['small', 'medium'])\n  }\n\n  static defaultProps = {\n    multiple: false,\n    disabled: false,\n    autoFocus: false,\n    maxHeight: null,\n    value: null,\n    valuesEquality: (a, b) => a === b,\n    onChange: () => {},\n    onEscKeyDown: () => {},\n    size: 'medium'\n  }\n\n  static childContextTypes = {\n    [MENU_ITEM_CONTEXT]: PropTypes.shape({\n      /**\n       * Проверка, выбрано ли значение (args: value)\n       */\n      isValueSelected: PropTypes.func,\n      /**\n       * Проверка, в фокусе ли значение (args: key)\n       */\n      isItemFocused: PropTypes.func,\n      /**\n       * Проверка, не активно ли меню\n       */\n      isMenuDisabled: PropTypes.func,\n      /**\n       * Получение размера меню\n       */\n      getMenuSize: PropTypes.func,\n      /**\n       * Шина событий\n       * onPropsChange - изменение значений props в Menu, влияющих на отображение опций\n       * onItemSelect - клик по MenuItem (args: value)\n       * onItemFocus - фокус на MenuItem (args: id)\n       * onItemMount - добавление и обновление MenuItem (args: id, componentInstanseRef)\n       * onItemUnmount - удаление MenuItem (args: id)\n       */\n      events: PropTypes.instanceOf(EventEmitter)\n    })\n  }\n\n  constructor(props) {\n    super(props)\n    this.value = props.multiple\n      ? Array.isArray(props.value)\n        ? props.value\n        : emptyArr\n      : props.value || null\n    this.state = {\n      value: this.value\n    }\n    this.focusIndex = -1\n    this.itemsKeys = []\n    this.registeredItems = {}\n  }\n\n  getChildContext() {\n    if (!this.events) this.createEvents()\n\n    return {\n      [MENU_ITEM_CONTEXT]: {\n        isValueSelected: this.isValueSelected,\n        isItemFocused: this.isItemFocused,\n        isMenuDisabled: this.isMenuDisabled,\n        getMenuSize: this.getMenuSize,\n        events: this.events\n      }\n    }\n  }\n\n  updateItemsKeys() {\n    const nodes = this.menu.querySelectorAll('[data-menu-item-id]')\n    this.itemsKeys = Array.prototype.slice\n      .call(nodes)\n      .map(node => node.getAttribute('data-menu-item-id'))\n  }\n\n  addItem = (key, ref) => {\n    this.registeredItems[key] = ref\n  }\n\n  removeItem = key => {\n    delete this.registeredItems[key]\n  }\n\n  createEvents() {\n    this.events = new EventEmitter()\n    this.events.setMaxListeners(0)\n    this.events.on('onItemSelect', this.handleOptionSelect)\n    this.events.on('onItemFocus', this.handleOptionFocus)\n    this.events.on('onItemMount', this.addItem)\n    this.events.on('onItemUnmount', this.removeItem)\n  }\n\n  componentDidMount() {\n    this.updateItemsKeys()\n    this.scrollToLastSelected()\n    if (this.props.autoFocus) this.setAutoFocus()\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setValue(nextProps.value)\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {props, state} = this\n    this.updateItemsKeys()\n    if (\n      props.disabled !== prevProps.disabled ||\n      props.size !== prevProps.size ||\n      state.value !== prevState.value\n    )\n      this.events.emit('onPropsChange')\n\n    if (this.props.autoFocus && !prevProps.autoFocus) this.setAutoFocus()\n  }\n\n  componentWillUnmount() {\n    if (this.events) this.events.removeAllListeners()\n  }\n\n  isValueSelected = value => {\n    const {props} = this\n    if (props.multiple) {\n      const selected = Array.isArray(this.value) ? this.value : emptyArr\n      return selected.some(item => props.valuesEquality(item, value))\n    } else {\n      return props.valuesEquality(this.value, value)\n    }\n  }\n\n  isItemFocused = key => {\n    const index = this.itemsKeys.indexOf(key)\n    return index > -1 ? index === this.focusIndex : false\n  }\n\n  isMenuDisabled = () => this.props.disabled\n\n  getMenuSize = () => this.props.size\n\n  scrollToLastSelected() {\n    const lastSelectedIndex = this.getLastSelectedIndex()\n    if (lastSelectedIndex === -1) return\n    const item = this.registeredItems[this.itemsKeys[lastSelectedIndex]]\n    if (!item) return\n    const menuRect = getBoundingClientRect(this.menu)\n    const itemRect = getBoundingClientRect(findDOMNode(item))\n    this.menu.scrollTop += itemRect.top - menuRect.top - menuRect.height / 2\n  }\n\n  setAutoFocus() {\n    const lastSelectedIndex = this.getLastSelectedIndex()\n    const newIndex = lastSelectedIndex > -1 ? lastSelectedIndex : 0\n    this.setFocusByIndex(newIndex)\n  }\n\n  setValue(value) {\n    if (this.props.multiple) {\n      const currValue = Array.isArray(this.value) ? this.value : emptyArr\n      const nextValue = Array.isArray(value) ? value : emptyArr\n      if (\n        nextValue.length === currValue.length &&\n        nextValue.every((item, index) =>\n          this.props.valuesEquality(item, currValue[index])\n        )\n      )\n        return\n    } else {\n      if (this.props.valuesEquality(value, this.value)) return\n    }\n    this.value = value\n    this.setState({value})\n  }\n\n  handleOptionFocus = key => {\n    const index = this.itemsKeys.indexOf(key)\n    if (index === -1) return\n    this.setFocusByIndex(index)\n  }\n\n  getLastSelectedIndex() {\n    return this.itemsKeys.reduceRight(\n      (result, key, index) =>\n        result === -1 && this.registeredItems[key].isSelected ? index : result,\n      -1\n    )\n  }\n\n  decrementFocusIndex() {\n    const maxIndex = this.itemsKeys.length - 1\n    this.setFocusByIndex(this.focusIndex <= 0 ? maxIndex : this.focusIndex - 1)\n  }\n\n  incrementFocusIndex() {\n    const maxIndex = this.itemsKeys.length - 1\n    this.setFocusByIndex(this.focusIndex >= maxIndex ? 0 : this.focusIndex + 1)\n  }\n\n  setFocusByIndex(focusIndex) {\n    if (focusIndex === this.focusIndex) return\n    this.focusIndex = focusIndex\n    this.events.emit('onPropsChange')\n  }\n\n  handleOptionSelect = value => {\n    const {props} = this\n    let nextValue\n    if (props.multiple) {\n      const currValue = Array.isArray(this.value) ? this.value : emptyArr\n      const withoutValue = currValue.filter(\n        v => !props.valuesEquality(v, value)\n      )\n      nextValue =\n        withoutValue.length === currValue.length\n          ? currValue.concat(value)\n          : withoutValue\n    } else {\n      nextValue = value\n    }\n    this.setValue(nextValue)\n    props.onChange(nextValue)\n  }\n\n  keyDown = event => {\n    const key = event.keyCode\n    const shift = event.shiftKey\n\n    if (key === ESCAPE) {\n      this.props.onEscKeyDown(event)\n    } else if (key === UP || (key === TAB && shift)) {\n      event.preventDefault()\n      this.decrementFocusIndex()\n    } else if (key === DOWN || (key === TAB && !shift)) {\n      event.preventDefault()\n      this.incrementFocusIndex()\n    }\n  }\n\n  handleBlur = () => {\n    this.focusIndex = -1\n  }\n\n  saveMenuRef = ref => {\n    this.menu = ref\n  }\n\n  getMenuProps() {\n    /* eslint-disable no-unused-vars */\n    const {\n      autoFocus,\n      value,\n      theme,\n      onChange,\n      onEscKeyDown,\n      multiple,\n      valuesEquality,\n      disabled,\n      size,\n      ...props\n    } = this.props\n    /* eslint-enable no-unused-vars */\n    return props\n  }\n\n  render() {\n    const {\n      className,\n      style,\n      maxHeight,\n      children,\n      classes,\n      ...other\n    } = this.getMenuProps()\n\n    return (\n      <div\n        {...other}\n        ref={this.saveMenuRef}\n        style={{maxHeight, ...style}}\n        className={classnames(classes.menu, className)}\n        onKeyDown={this.keyDown}\n        onBlur={this.handleBlur}>\n        {children}\n      </div>\n    )\n  }\n}\n"},831:function(e,n){e.exports="import React, {Component} from 'react'\nimport {Menu, MenuItem} from 'rambler-ui/Menu'\nimport Checkbox from 'rambler-ui/Checkbox'\n\nconst data = ['Foo', 'Bar', 'Baz'].map(category => ({\n  category,\n  items: [...Array(5)].map((item, i) => `${category}${i}`)\n}))\n\nclass IsolatedMenuItem extends Component {\n  shouldComponentUpdate() {\n    return false\n  }\n  render() {\n    return <MenuItem {...this.props} />\n  }\n}\n\nexport default class MenuExample extends Component {\n  state = {\n    small: false,\n    disabled: false,\n    value: [data[2].items[0]]\n  }\n\n  toggleValue = valueKey => () => {\n    this.setState({\n      [valueKey]: !this.state[valueKey]\n    })\n  }\n\n  setValue = value => {\n    this.setState({\n      value\n    })\n  }\n\n  render() {\n    const {state} = this\n    return (\n      <div style={{maxWidth: 300}}>\n        <div>\n          <Checkbox\n            style={{marginRight: 20}}\n            checked={state.small}\n            onCheck={this.toggleValue('small')}>\n            size: small\n          </Checkbox>\n          <Checkbox\n            checked={state.disabled}\n            onCheck={this.toggleValue('disabled')}>\n            disabled\n          </Checkbox>\n        </div>\n        <Menu\n          multiple={true}\n          value={state.value}\n          onChange={this.setValue}\n          size={state.small ? 'small' : 'medium'}\n          disabled={state.disabled}\n          style={{margin: '20px 0', border: '1px solid'}}\n          maxHeight={180}>\n          {data.map((category, categoryIndex) => (\n            <div\n              style={{borderTop: categoryIndex ? '1px solid #ddd' : null}}\n              key={categoryIndex}>\n              <h5 style={{margin: 0, padding: 13}}>{category.category}</h5>\n              {category.items.map((item, itemIndex) => (\n                <IsolatedMenuItem value={item} key={itemIndex}>\n                  {item}\n                </IsolatedMenuItem>\n              ))}\n            </div>\n          ))}\n        </Menu>\n        <div>{`state: ${JSON.stringify(this.state.value)}`}</div>\n      </div>\n    )\n  }\n}\n"}}]);